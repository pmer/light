use geometry::*;

// Octants of a circle if said circle were drawn starting at 3 PM and moving counter-clockwise.
pub enum Octant {
    One,    // 0 to π/4
    Two,    // π/4 to π/2
    Three,  // etc.
    Four,
    Five,
    Six,
    Seven,
    Eight,
}

// Bresenham’s line algorithm
pub fn bresenham(a: Point, b: Point) -> Vec<Point> {
    let mut line = vec![];
    let dx = b.x - a.x;
    let dy = b.y - a.y;

    // If the line is vertical.
    if dx == 0 {
        let x = a.x;
        let top = if dx < dy { dx } else { dy };
        let bot = if dx < dy { dy } else { dx };
        for y in top..bot {
            line.push(Point { x, y });
        }
        return line;
    }

    // TODO: Rest of algorithm.

    line
}

fn determine_octant(p: Point) -> Octant {
    let Point { x, y } = p;
    if x > 0 {

    } else {

    }

    Octant::One
}

fn toOctantZero(octant: Octant, p: Point) -> Point {
    let Point { x, y } = p;
    match octant {
        Octant::One => p,
        Octant::Two => Point { x: y, y: x },
        Octant::Three => Point { x: y, y: -x },
        Octant::Four => Point { x: -x, y: y },
        Octant::Five => Point { x: -x, y: -y },
        Octant::Six => Point { x: -y, y: -x },
        Octant::Seven => Point { x: -y, y: x },
        Octant::Eight => Point { x: x, y: -y },
    }
}

fn fromOctantZero(octant: Octant, p: Point) -> Point {
    let Point { x, y } = p;
    match octant {
        Octant::One => p,
        Octant::Two => Point { x: y, y: x },
        Octant::Three => Point { x: -y, y: x },
        Octant::Four => Point { x: -x, y: y },
        Octant::Five => Point { x: -x, y: -y },
        Octant::Six => Point { x: -y, y: -x },
        Octant::Seven => Point { x: y, y: -x },
        Octant::Eight => Point { x: x, y: -y },
    }
}
